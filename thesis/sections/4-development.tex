\section{Development}

When trying to follow a traditional software engineering approach to in
Haskell, one soon runs into several dead ends: due to the different paradigm
and style, trying to apply some methods feels forced or unnatural.
Traditionally, in Haskell the approach when formalizing a piece of code just
involves a mathematical validation, using pure Mathematics for a formal design
through equations, that can then verified by a theorem prover such as Agda or
Coq. Furthermore, the problems only increase when we try to use UML: this
methodology was clearly not designed for other than Object-Oriented programming
and it is not possible to create traditional diagrams for Haskell without
running in unforgivable simplifications, inaccuracies regarding the system or
simply nonsensical diagrams. \\

However, due to the academic character of this thesis, it is needed to provide
some formal specification of the system using the learned methodologies for
software development, so we will try to use the appropriate mathematical
concepts embedded (as long as they are manageable and in the scope of the
thesis), as well as more familiar specification systems for Haskell projects
like the type specification. Please, bear in mind that this is not usually the
case in Haskell projects and the recommended guidelines just include formal
specification through mathematical definition and theorem proving. \\

\subsection{Use Cases}

To start designing the library, first we have to formally specify the use cases
of possible users of the library. The agents involved in this specifications
are simply the end user and the library itself, which will provide functions
for the user by demand.\\

\begin{table}[h]
  \centering
  \rowcolors{2}{gray90}{white}

\begin{tabular}{
  !{\color{azulUC3M}\vline} p{4cm}
  !{\color{azulUC3M}\vline} p{6cm}
  !{\color{azulUC3M}\vline}}
  \arrayrulecolor{azulUC3M}
  \rowcolor{azulUC3M}

  \multicolumn{1}{l !{\color{white}\vline}}
  {\color{white}{\texttt{ID}}}
  & \multicolumn{1}{l}
    {\color{white}{\texttt{UC-XX}}} \\
  
  \textit{Title}         & \\
  \textit{Actor}         & \\
  \textit{Preconditions} & \\
  \textit{Description}   & \\
  \hline
\end{tabular}
\caption{Use Case template}
\label{uc-ex}
\end{table}

All the use cases that will be covered will be specified in individual tables
following the template in the Table \ref{uc-ex}. Each of the use cases will
receive a unique identifier of the format \texttt{UC-XX}, where \texttt{XX} is
a double digit number. This unique identifier will be used later on different
matrices to trace requirements. The complete set of use cases for the library
is stated following this page.

\newpage

\begin{uc3m-table}{UC-01}{Use Case \texttt{UC-01}}
  \textit{Title} & \textbf{Solve a search problem} \\
  \textit{Actor} & User \\
  \textit{Preconditions} &
  The user has a compatible representation of the problem programmed in
  Haskell, and the package \texttt{agis} is already installed in their system.
  \\
  \textit{Description} &
  The user imports the module containing the algorithm that he wants to use,
  and includes the functionality in their code. Then, the user can run the code
  to obtain the solution found.\\
\end{uc3m-table}


\begin{uc3m-table}{UC-02}{Use Case \texttt{UC-02}}
  \textit{Title} & \textbf{Solve a search problem and get statistics} \\
  \textit{Actor} & User \\
  \textit{Preconditions} &
  The user has a compatible representation of the problem programmed in
  Haskell, and the package \texttt{agis} is already installed in their system.
  \\
  \textit{Description} &
  The user imports the module containing the monadic version of the algorithm
  that he wants to use, and includes the functionality in their code. Then, the
  user can run the code to obtain the solution found and several search
  statistics.\\  
\end{uc3m-table}


\begin{uc3m-table}{UC-03}{Use Case \texttt{UC-03}}
  \textit{Title} & \textbf{Design a new search algorithm} \\
  \textit{Actor} & User \\
  \textit{Preconditions} &
  The package \texttt{agis} is already installed in the user's system. \\
  \textit{Description} &
  The user can import the module containing several functions that they can use
  to build their algorithm, as well as using a monadic version of those
  functions to gain a better understanding on the algorithm.\\ 
\end{uc3m-table}


\begin{uc3m-table}{UC-04}{Use Case \texttt{UC-04}}
  \textit{Title} & \textbf{Test a new algorithm} \\
  \textit{Actor} & User \\
  \textit{Preconditions} &
  The package \texttt{agis} is already installed in the user's system, and the
  user has already implemented their algorithm using the library types and
  functions. \\
  \textit{Description} &
  The user can import several toy problems that the library offers to test that
  algorithm to check the behavior or performance.\\ 
\end{uc3m-table}


\begin{uc3m-table}{UC-05}{Use Case \texttt{UC-05}}
  \textit{Title} & \textbf{Compare a new algorithm} \\
  \textit{Actor} & User \\
  \textit{Preconditions} &
  The package \texttt{agis} is already installed in the user's system, and the
  user has already implemented their algorithm using the library types and
  functions.\\
  \textit{Description} &
  The user can import more algorithms from the library and trivially apply one
  or another to the same problem space, to check the performance of both of
  them side by side.\\
\end{uc3m-table}


\newpage 

\subsection{Requirements}

Once all the use cases have been defined for the library, we can design all the
functional and non-functional requirements of the library. These requirements
will be formalized in a similar table to those for the use cases, that can be
seen in Table \ref{r-ex}.

\begin{table}[h]
  \centering
  \rowcolors{2}{gray90}{white}

\begin{tabular}{
  !{\color{azulUC3M}\vline} p{4cm}
  !{\color{azulUC3M}\vline} p{6cm}
  !{\color{azulUC3M}\vline}}
  \arrayrulecolor{azulUC3M}
  \rowcolor{azulUC3M}

  \multicolumn{1}{l !{\color{white}\vline}}
  {\color{white}{\texttt{ID}}}
  & \multicolumn{1}{l}
    {\color{white}{\texttt{FR-XX || NFR-XX}}} \\
  
  \textit{Title}         & \\
  \textit{Description}   & \\
  \textit{Priority}      & \\
  \textit{Use-case(s)}   & \\
  \hline
\end{tabular}
\caption{Requirement template}
\label{r-ex}
\end{table}

Every functional requirement (that specifies a function that has to be offered
by the library) will be tagged using an unique identifier with the format
\texttt{FR-XX}, where the \texttt{XX} represent a double digit number. On the
other hand, all the non-functional requirements (associated with preconditions
or other context necessary for the library to correctly work) will be
identified with the tags \texttt{NFR-XX}, where once again the \texttt{XX}
stands for a double digit number.

\newpage

\subsubsection{Functional Requirements}

\begin{uc3m-table}{FR-01}{Functional Requirement \texttt{FR-01}}
  \textit{Title}         & \textbf{Set of data types and classes} \\
  \textit{Description}   &
  All end-user types have to be well documented and offered to the user due to
  Haskell's strongly typing system.\\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-02, UC-03, UC-04, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-02}{Functional Requirement \texttt{FR-02}}
  \textit{Title}         & \textbf{Pure general search method} \\
  \textit{Description}   &
  Following the general search algorithm mentioned in \cite{rusell-2003-aima},
  offer a function with similar capabilities while purely functional. As the
  one in the book, it should behave differently by the order of nodes in the
  open list. Due to this open list of nodes, it will use non-linear memory. \\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-03} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-03}{Functional Requirement \texttt{FR-03}}
  \textit{Title}         & \textbf{Pure linear-memory search method} \\
  \textit{Description}   &
  Offer a method that is able to perform search using linear memory in a purely
  functional way.\\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-03} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-04}{Functional Requirement \texttt{FR-04}}
  \textit{Title}         & \textbf{Pure data structure interface} \\
  \textit{Description}   &
  A data structure interface to hold the nodes open list in general search has
  to be provided. This interface has to be defined as a Haskell class and be
  well documented, as well as exported for the user to implement their own data
  structures.\\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-03} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-05}{Functional Requirement \texttt{FR-05}}
  \textit{Title}         & \textbf{Library of pure data structures} \\
  \textit{Description}   &
  Using the aforementioned data structure interface, the library should also
  provide a set of curated, purely functional data structures as the ones
  exposed in \cite{okasaki-1999-purely}. The exact set of data structures is
  left to decide once the implementation starts, choosing the more convenient
  ones for both the library and the user. \\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-03} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-06}{Functional Requirement \texttt{FR-06}}
  \textit{Title}         & \textbf{Library of toy problems} \\
  \textit{Description}   &
  The library should include a set of already implemented problems that enables
  the users to solve them by using algorithms that use the library's data types
  (whether the ones provided by the library or ones implemented by themselves).
  \\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-04, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-07}{Functional Requirement \texttt{FR-07}}
  \textit{Title}         & \textbf{Pure Breadth-First Search} \\
  \textit{Description}   &
  Offer a function able to perform a Breadth-First Search that returns the list
  of all solutions found that way in the problem space. Breadth-First Search
  should be implemented using general search (\texttt{FR-02}) and a First-In,
  First-Out queue (\texttt{FR-05}). \\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-08}{Functional Requirement \texttt{FR-08}}
  \textit{Title}         & \textbf{Pure Depth-First Search} \\
  \textit{Description}   &
  Offer a function able to perform a Depth-First Search that returns the list
  of all solutions found that way in the problem space. Depth-First Search
  should be implemented using linear-memory search (\texttt{FR-03}) or a
  Last-In, First-Out stack (\texttt{FR-05}).\\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-09}{Functional Requirement \texttt{FR-09}}
  \textit{Title}         & \textbf{Pure Iterative Depth-First Search} \\
  \textit{Description}   &
  Offer a function able to perform an Iterative Depth-First Search that returns
  the list of all solutions found that way in the problem space. Iterative
  Depth-First Search should be implemented using linear-memory search
  iteratively (\texttt{FR-03}) or a Last-In, First-Out depth-bounded stack
  (\texttt{FR-05}). \\ 
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-10}{Functional Requirement \texttt{FR-10}}
  \textit{Title}         & \textbf{Pure Uniform-Cost Search} \\
  \textit{Description}   &
  Offer a function able to perform an Uniform-Cost Search that returns
  the list of all solutions found that way in the problem space. Uniform-Cost
  Search should be implemented using linear-memory search (\texttt{FR-03})
  iteratively (\texttt{FR-03}). \\ 
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-05} \\
\end{uc3m-table}



\subsubsection{Non-Functional Requirements}
\subsubsection{Traceability Matrix}

\subsection{Implementation}

\newpage