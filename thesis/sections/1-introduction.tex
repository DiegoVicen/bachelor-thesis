\section{Introduction}

The functional programming paradigm is nowadays an upward trend
\cite{ford-2013-ibm}, whose popularity can be traced to the several advantages
it offers: an arguably easier way of reasoning about its concepts, the use of
high-level abstractions that can be used for both reducing the workload on the
developers and including optimizations in the compiled code, or the fact that
its characteristics and principles make the fact of turning purely functional
code into concurrent code a trivial task \cite{hammond-2012-parallel}. This is
done by radically stripping the side effects from the code and keeping the
state of the machine immutable, or more recently, by isolating them and keeping
the referential transparency intact through as much as possible of the code base.\\

This trend is present in new languages being developed with the functional
paradigm: for instance, Scala \cite{scala} is a functional, strongly-typed
language based on the Java virtual machine, which makes it able to be used for
Android applications development. Another interesting example is Elm
\cite{elm}, which compiles to HTML, CSS and Javascript allowing functional web
development. But not only new languages are being inspired by functional
programming: long-established languages are also introducing functional
concepts such as Map-Reduce, folds, higher-order or anonymous functions into
traditional workflows. Some examples of this include Java \cite{java8},
C++ \cite{cpp-lambdas, cpp-high-level} or Python \cite{python-mrs}.\\

The flagship language of the functional paradigm is Haskell \cite{haskell-98}.
Among its main features we can highlight the fact that it is purely functional
(and allows complete referential transparency by isolating the side effects),
lazy (contrary to strict evaluation, laziness imply that only the required
results are computed among all definitions), strongly and statically typed (all
types are checked at compile time) and provides a great set of abstractions
that can be compiled into concurrent code. This particularities have placed on
Haskell the stigma of being an academic language, with hardly any practical use
on real life; a stigma that the community has worked exhaustively to get rid
of.\\

Ironically enough, some Computer Science fields seem like unexplored territory
in Haskell. For example, a quick query on how many Haskell packages are
available on the most popular Haskell package manager related to heuristic
search returns a scarce set of algorithms, with different specifications and
barely any cohesion between them. That makes the task of studying the behavior
of different search algorithms in functional programming too much of a hassle,
compared to other languages with solid developed frameworks.\\

Out of this necessity the idea of \emph{Agis} is born: a full-fledged,
functional heuristic search framework. Agis not only provides a heuristic
search library with well known algorithms, but also the building blocks used to
implement them and a suite of different interfaces to performance and
automation tools for Haskell. The library is divided in two different flavors:
\texttt{Search.Pure}, which provides a set of completely pure functional
algorithms implemented and ready to be used; and \texttt{Search.Monadic}, which
adds a new layer of complexity using a monad that wraps the search. This causes
a time and space overhead with the advantage of being able to gather run-time
statistics, that can be used for educational, algorithm design or research
purposes. 

\newpage