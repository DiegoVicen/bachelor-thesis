\section{Introduction}

The functional programming paradigm is nowadays an upward trend [CITATION
NEEDED], whose popularity can be traced to the several advantages it offers: an
arguably easier way of reasoning about its concepts, the use of high-level
abstractions that can be used for both reducing the workload on the developers
and including optimizations in the compiled code, or the fact that its
characteristics and principles make the fact of turning purely functional code
into concurrent code a trivial task [CITATION NEEDED].\\

This trend is present in new languages being developed with the functional
paradigm: for instance, Scala [CITATION NEEDED] is a functional strongly-typed
language based on the Java virtual machine, which makes it able to be used for
Android applications development. Another interesting example is Elm [CITATION
NEEDED], which compiles to Javascript and allows functional web development.
But not only new languages are using functional programming: long-established
languages are also introducing functional concepts such as Map-Reduce, folds,
higher-order or anonymous functions into traditional workflows. Some examples
of this include Java [CITATION NEEDED], C++ [CITATION NEEDED] or Python
[CITATION NEEDED].\\

% Paragraph about Haskell

However, there are several Computer Science fields that seem to belong to just
one paradigm. For example, a quick query on how many Haskell packages are
available on the most popular Haskell package manager related to heuristic
search returns a scarce set of algorithms, with different specifications and
barely any cohesion between them. That makes the task of studying the behavior
of different search algorithms in functional programming too much of a hassle,
compared to other languages with solid developed frameworks.\\

Out of this necessity the idea of \emph{Agis} is born: a full-fledged,
functional heuristic search framework. Agis not only provides a heuristic
search library with well known algorithms, but also the building blocks used to
implement them and a suite of different interfaces to performance and
automation tools for Haskell. The library is divided in two different flavors:
\texttt{Search.Pure}, which provides a set of completely pure functional
algorithms implemented and ready to be used; and \texttt{Search.Monadic}, which
adds a new layer of complexity using a monad that wraps the search. This causes
a time and space overhead with the advantage of being able to gather run-time
statistics, that can be used for educational, algorithm design or research
purposes.
