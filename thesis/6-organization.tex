\section{Project Organization \& Management}

\subsection{Planning}

\subsubsection{Time Management}

For a project of this size, it is important to develop a plan that states
different stages.\\

\begin{figure}[ht]
  \centering
  \begin{ganttchart}[vgrid = dotted, hgrid = dotted, compress calendar,
    time slot format=isodate-yearmonth, x unit = 8mm,
    group left shift = 0.1, group right shift = -0.1,
    title/.append style={fill=azulUC3M, draw=white, thick},
    title label font=\color{white}\ttfamily,
    title height = 1,
    group/.append style={fill=azulUC3M},
    group label font = \small,
    bar/.append style={fill=azulUC3M},
    bar label font = \small,
    milestone/.append style={draw=azulUC3M, fill=azulUC3M},
    milestone label font = \small,
    link/.append style={azulUC3M}]
    {2016-09}{2017-09}
    \gantttitlecalendar{year, month} \\
    
    \ganttgroup{Phases}{2016-09}{2017-02}
    \ganttgroup{}{2017-03}{2017-06}
    \ganttgroup{}{2017-07}{2017-09} \\

    % \ganttgroup{Research}{2016-09}{2017-06} \\
    \ganttbar{Previous Research}{2016-09}{2016-10} \\
    \ganttlinkedbar{Analysis}{2016-10}{2016-11} \\
    \ganttlinkedbar{Design \& Modelling}{2016-12}{2017-02} \\ 
    \ganttlinkedmilestone{Initial design}{2017-02} \\
    
    % \ganttgroup{Development}{2017-03}{2017-09} \\
    \ganttlinkedbar{Implementation}{2017-03}{2017-05} \\
    \ganttlinkedbar{Testing}{2017-04}{2017-06} \\
    \ganttlinkedmilestone{\texttt{v0.1.0.0}}{2017-06} \\
    
    % \ganttgroup{Testing}{2017-07}{2017-09} \\
    \ganttlinkedbar{Iteration}{2017-07}{2017-08} \\
    \ganttlinkedmilestone{\texttt{v0.2.0.0}}{2017-08}
    \end{ganttchart}
  \caption{Gantt chart for the project.}
  \label{gantt}
\end{figure}

\subsubsection{Version Control \& Continuous Integration}

To manage all the code in the project, it is a must to use a Version Control
System (VCS). The chosen system for the project is Git, a widespread
distributed VCS that allows us to keep track of all changes in the code in all
developing devices as well as in a remote server \cite{chacon-2009-git}. The
way Git works allows us to maintain all the code in the repository and enables
different collaboration dynamics that will be required for the open release of
the project.\\

One of the main features of Git is the branching system: a repository contains
one main branch (\texttt{master}), which contains all the commits (snapshots
that include all code at a certain point in time in the project) associated
with it. The users can create a new branch from it, to add new features or try
new implementations, and merge back the changes when satisfied or keep on
creating new branches on it. This system allows a great flexibility, which can
sometimes become a problem; for that reason some workflows have been designed
to impose some restrictions to Git usage in big projects that are maintained by
several developers. For this project, the choice used is a slight modification
of Git-flow \cite{driessen-2010-gitflow}, that uses the \texttt{master} branch
as the branch where \texttt{HEAD} represents the last delivered development
changes. In the original workflow proposed, this branch is only for
production-ready code, but the author considers this redundant and in the
project repository it is stated that the production-ready code is the one
tagged as releases in the repository \cite{chacon-2009-git}, and distributed in
the Haskell package managers available. All support branches should be branched
from \texttt{master} and merged back into it once the code is ready, as stated
in the \texttt{CONTRIBUTING} file.\\

However, we also must define what ``ready'' actually means: to do so, we will
rely in one of the tools provided by the third-party service that hosts the
code: GitLab, which offers the possibility of configuring different Continuous
Integration tasks and pipelines. Continuous Integration is the practice of
merging often the developer copies of the project into the main repository
\cite{fowler-2006-ci}, and the tools provided by the service allows us to run
some code on the server side and return some insights. In this particular case,
the pipeline configured installs a Docker image containing Haskell, installs
and builds the project and then runs the tests defined in the project's test
suite. This configuration is stored in the file \texttt{.gitlab-ci.yaml} and
can be read in Listing \ref{git-ci}.\\

\begin{lstlisting}[label=git-ci,
caption=Continuous Integration pipeline configuration]
image: haskell:8.0

before_script:
  - cabal update
  - cabal install --only-dependencies --enable-tests

test:
  script:
  - cabal configure --enable-tests
  - cabal build
  - cabal test
\end{lstlisting}

If the project can install all dependencies, be compiled and run all tests
without failures, the commit gets tagged as ``passed''. If not, the build is
considered to fail and an email notification gets sent to the collaborator that
pushed the code to the repository. Only passed pull-requests can be merged into
master, forcing the work-in-progress to stay in the adequate branch and the
code to be ready before be merged into the master branch.\\


\subsection{Budget}

\subsection{Open-Sourcing the Project}

\subsubsection{License \& Legal Framework}

Making the project open source requires a deep research of the available
distribution licenses for this type of works. To be able to choose the adequate
license, first it is needed to state the objectives of the project: What are the
goals trying to be achieved? Once the target is well defined, it will be an
easy task to choose an adequate license from the ones available
\cite{morin-2012-license}.\\

When making this project open source, the main goal in this project is
for it to be improved and peer-reviewed by potential users and contributors.
Although the project is right now a functional piece of software, the
complexity of techniques in the software and elaborate abstractions used in
Haskell leave a great room for improvement: a cleaner code and a greater
performance can still be obtained. Apart from improving the present state of
the code, the adding of new features by some users can be interesting, like
algorithms or automation features for the framework. For that reason, the
license needs to be flexible for the user while ensuring transparency and a
completely open development.\\

Following these characteristics, the most adequate license found for the
project is the GNU General Public License v3.0, which ensures that the code is
open and free, and all variations of it are forced to maintain this status.
This will help the project take advantage of any feedback in derivatives as
well as spreading the open-nature of this license. This license provides
reasonable constraints for businesses as well as appropriate perks for
education: commercial use, distribution, modification, patent use, and private
use are allowed as long as the source code is disclosed, licensed under the
same license and the changes performed are stated. This license also provides
no liability or warranty with the software.\\

\subsubsection{Contribution Workflow}

Since the project aims to attract users to contribute, it is considered a good
practice to offer some contribution guidelines for interested users to follow.
This guidelines are collected in the file \texttt{CONTRIBUTING} and gather all
the steps to have homogeneous code and methodologies throughout the whole
project. In this section, this guidelines will be explained on detail.\\

First, the user is asked to create a new issue in the remote repository
provider, GitLab. This prevents two users to start working on clashing or
redundant tasks and offers a better perspective when organizing the project.
Some guidelines are also given when forking or branching (following the scheme
specified before for branching/merging). There is a special emphasis on test
creation: this will prevent future refactors or improvements to break previous
features. Once the contribution is ready on a forked version of the repository,
a pull-request can be performed. This will no automatically merge the code, but
instead it will start a code review process. This code review will ensure that
the code has been developed following the guidelines mentioned, and will enable
feedback from the project maintainer(s) to the user in order to create better,
more adequate code for the project \cite{beller-2014-review}. Once the code
review has been approved, the code is merged to the main code and only accepted
in the repository if all the Continuous Integration stages (install
dependencies, building and testing) are properly completed.\\

\newpage

%%% Local Variables:
%%% TeX-master: "tfg"
%%% End:
