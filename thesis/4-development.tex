\section{Development}

When trying to follow a traditional software engineering approach to in
Haskell, one soon runs into several dead ends: due to the different paradigm
and style, trying to apply some methods feels forced or unnatural.
Traditionally, in Haskell the approach when formalizing a piece of code just
involves a mathematical validation, using pure Mathematics for a formal design
through equations, that can then verified by a theorem prover such as Agda or
Coq. Furthermore, the problems only increase when we try to use UML: this
methodology was clearly not designed for other than Object-Oriented programming
and it is not possible to create traditional diagrams for Haskell without
running in unforgivable simplifications, inaccuracies regarding the system or
simply nonsensical diagrams. \\

However, due to the academic character of this thesis, it is needed to provide
some formal specification of the system using the learned methodologies for
software development, so we will try to use the appropriate mathematical
concepts embedded (as long as they are manageable and in the scope of the
thesis), as well as more familiar specification systems for Haskell projects
like the type specification. Please, bear in mind that this is not usually the
case in Haskell projects and the recommended guidelines just include formal
specification through mathematical definition and theorem proving. \\

\subsection{Use Cases}

To start designing the library, first we have to formally specify the use cases
of possible users of the library. The agents involved in this specifications
are simply the end user and the library itself, which will provide functions
for the user by demand.\\

\begin{table}[h]
  \centering
  \rowcolors{2}{gray90}{white}

\begin{tabular}{
  !{\color{azulUC3M}\vline} p{4cm}
  !{\color{azulUC3M}\vline} p{6cm}
  !{\color{azulUC3M}\vline}}
  \arrayrulecolor{azulUC3M}
  \rowcolor{azulUC3M}

  \multicolumn{1}{l !{\color{white}\vline}}
  {\color{white}{\texttt{ID}}}
  & \multicolumn{1}{l}
    {\color{white}{\texttt{UC-XX}}} \\
  
  \textit{Title}         & \\
  \textit{Actor}         & \\
  \textit{Preconditions} & \\
  \textit{Description}   & \\
  \hline
\end{tabular}
\caption{Use Case template}
\label{uc-ex}
\end{table}

All the use cases that will be covered will be specified in individual tables
following the template in the Table \ref{uc-ex}. Each of the use cases will
receive a unique identifier of the format \texttt{UC-XX}, where \texttt{XX} is
a double digit number. This unique identifier will be used later on different
matrices to trace requirements. The complete set of use cases for the library
is stated following this page.

\newpage

\begin{uc3m-table}{UC-01}{Use Case \texttt{UC-01}}
  \textit{Title} & \textbf{Solve a search problem} \\
  \textit{Actor} & User \\
  \textit{Preconditions} &
  The user has a compatible representation of the problem programmed in
  Haskell, and the package \texttt{agis} is already installed in their system.
  \\
  \textit{Description} &
  The user imports the module containing the algorithm that he wants to use,
  and includes the functionality in their code. Then, the user can run the code
  to obtain the solution found.\\
\end{uc3m-table}


\begin{uc3m-table}{UC-02}{Use Case \texttt{UC-02}}
  \textit{Title} & \textbf{Solve a search problem and get statistics} \\
  \textit{Actor} & User \\
  \textit{Preconditions} &
  The user has a compatible representation of the problem programmed in
  Haskell, and the package \texttt{agis} is already installed in their system.
  \\
  \textit{Description} &
  The user imports the module containing the monadic version of the algorithm
  that he wants to use, and includes the functionality in their code. Then, the
  user can run the code to obtain the solution found and several search
  statistics.\\  
\end{uc3m-table}


\begin{uc3m-table}{UC-03}{Use Case \texttt{UC-03}}
  \textit{Title} & \textbf{Design a new search algorithm} \\
  \textit{Actor} & User \\
  \textit{Preconditions} &
  The package \texttt{agis} is already installed in the user's system. \\
  \textit{Description} &
  The user can import the module containing several functions that they can use
  to build their algorithm, as well as using a monadic version of those
  functions to gain a better understanding on the algorithm.\\ 
\end{uc3m-table}


\begin{uc3m-table}{UC-04}{Use Case \texttt{UC-04}}
  \textit{Title} & \textbf{Test a new algorithm} \\
  \textit{Actor} & User \\
  \textit{Preconditions} &
  The package \texttt{agis} is already installed in the user's system, and the
  user has already implemented their algorithm using the library types and
  functions. \\
  \textit{Description} &
  The user can import several toy problems that the library offers to test that
  algorithm to check the behavior or performance.\\ 
\end{uc3m-table}


\begin{uc3m-table}{UC-05}{Use Case \texttt{UC-05}}
  \textit{Title} & \textbf{Compare a new algorithm} \\
  \textit{Actor} & User \\
  \textit{Preconditions} &
  The package \texttt{agis} is already installed in the user's system, and the
  user has already implemented their algorithm using the library types and
  functions.\\
  \textit{Description} &
  The user can import more algorithms from the library and trivially apply one
  or another to the same problem space, to check the performance of both of
  them side by side.\\
\end{uc3m-table}


\newpage 

\subsection{Requirements}

Once all the use cases have been defined for the library, we can design all the
functional and non-functional requirements of the library. These requirements
will be formalized in a similar table to those for the use cases, that can be
seen in Table \ref{r-ex}.

\begin{table}[h]
  \centering
  \rowcolors{2}{gray90}{white}

\begin{tabular}{
  !{\color{azulUC3M}\vline} p{4cm}
  !{\color{azulUC3M}\vline} p{6cm}
  !{\color{azulUC3M}\vline}}
  \arrayrulecolor{azulUC3M}
  \rowcolor{azulUC3M}

  \multicolumn{1}{l !{\color{white}\vline}}
  {\color{white}{\texttt{ID}}}
  & \multicolumn{1}{l}
    {\color{white}{\texttt{FR-XX || NFR-XX}}} \\
  
  \textit{Title}         & \\
  \textit{Description}   & \\
  \textit{Priority}      & \\
  \textit{Use-case(s)}   & \\
  \hline
\end{tabular}
\caption{Requirement template}
\label{r-ex}
\end{table}

Every functional requirement (that specifies a function that has to be offered
by the library) will be tagged using an unique identifier with the format
\texttt{FR-XX}, where the \texttt{XX} represent a double digit number. On the
other hand, all the non-functional requirements (associated with preconditions
or other context necessary for the library to correctly work) will be
identified with the tags \texttt{NFR-XX}, where once again the \texttt{XX}
stands for a double digit number.

\newpage

\subsubsection{Functional Requirements}

\begin{uc3m-table}{FR-01}{Functional Requirement \texttt{FR-01}}
  \textit{Title}         & \textbf{Set of data types and classes} \\
  \textit{Description}   &
  All end-user types have to be well documented and offered to the user due to
  Haskell's strongly typing system.\\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-02, UC-03, UC-04, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-02}{Functional Requirement \texttt{FR-02}}
  \textit{Title}         & \textbf{Pure general search method} \\
  \textit{Description}   &
  Following the general search algorithm mentioned in \cite{rusell-2003-aima},
  offer a function with similar capabilities while purely functional. As the
  one in the book, it should behave differently by the order of nodes in the
  open list. Due to this open list of nodes, it will use non-linear memory. \\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-03} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-03}{Functional Requirement \texttt{FR-03}}
  \textit{Title}         & \textbf{Pure linear-memory search method} \\
  \textit{Description}   &
  Offer a method that is able to perform search using linear memory in a purely
  functional way.\\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-03} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-04}{Functional Requirement \texttt{FR-04}}
  \textit{Title}         & \textbf{Pure data structure interface} \\
  \textit{Description}   &
  A data structure interface to hold the nodes open list in general search has
  to be provided. This interface has to be defined as a Haskell class and be
  well documented, as well as exported for the user to implement their own data
  structures.\\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-03} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-05}{Functional Requirement \texttt{FR-05}}
  \textit{Title}         & \textbf{Library of pure data structures} \\
  \textit{Description}   &
  Using the aforementioned data structure interface, the library should also
  provide a set of curated, purely functional data structures as the ones
  exposed in \cite{okasaki-1999-purely}. The exact set of data structures is
  left to decide once the implementation starts, choosing the more convenient
  ones for both the library and the user. \\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-03} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-06}{Functional Requirement \texttt{FR-06}}
  \textit{Title}         & \textbf{Library of toy problems} \\
  \textit{Description}   &
  The library should include a set of already implemented problems that enables
  the users to solve them by using algorithms that use the library's data types
  (whether the ones provided by the library or ones implemented by themselves).
  \\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-04, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-07}{Functional Requirement \texttt{FR-07}}
  \textit{Title}         & \textbf{Pure Breadth-First Search} \\
  \textit{Description}   &
  Offer a function able to perform a Breadth-First Search that returns the list
  of all solutions found that way in the problem space. Breadth-First Search
  should be implemented using general search (\texttt{FR-02}) and a First-In,
  First-Out queue (\texttt{FR-05}). \\
  \textit{Priority}      & Medium \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-08}{Functional Requirement \texttt{FR-08}}
  \textit{Title}         & \textbf{Pure Depth-First Search} \\
  \textit{Description}   &
  Offer a function able to perform a Depth-First Search that returns the list
  of all solutions found that way in the problem space. Depth-First Search
  should be implemented using linear-memory search (\texttt{FR-03}) or a
  Last-In, First-Out stack (\texttt{FR-05}).\\
  \textit{Priority}      & Medium \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-09}{Functional Requirement \texttt{FR-09}}
  \textit{Title}         & \textbf{Pure Iterative Depth-First Search} \\
  \textit{Description}   &
  Offer a function able to perform an Iterative Depth-First Search that returns
  the list of all solutions found that way in the problem space. Iterative
  Depth-First Search should be implemented using linear-memory search
  iteratively (\texttt{FR-03}) or a Last-In, First-Out depth-bounded stack
  (\texttt{FR-05}). \\ 
  \textit{Priority}      & Medium \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-10}{Functional Requirement \texttt{FR-10}}
  \textit{Title}         & \textbf{Pure Uniform-Cost Search} \\
  \textit{Description}   &
  Offer a function able to perform an Uniform-Cost Search that returns
  the list of all solutions found that way in the problem space. Uniform-Cost
  Search should be implemented using linear-memory search (\texttt{FR-03}).\\
  \textit{Priority}      & High \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-11}{Functional Requirement \texttt{FR-11}}
  \textit{Title}         & \textbf{Pure Greedy Search} \\
  \textit{Description}   &
  Offer a function able to perform a Greedy Search that returns the list of all
  solutions found that way in the problem space. Greedy Search should be
  implemented using linear-memory search (\texttt{FR-03})
  expanding the nodes with a minimal-heuristic order.\\
  \textit{Priority}      & Medium \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-12}{Functional Requirement \texttt{FR-12}}
  \textit{Title}         & \textbf{Pure A* Search} \\
  \textit{Description}   &
  Offer a function able to perform an A* Search that returns
  the list of all solutions found that way in the problem space. A*
  Search should be implemented using general search (\texttt{FR-02})
  using a priority queue to expand the nodes (\texttt{FR-05}). \\
  \textit{Priority}      & Medium \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-05} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-13}{Functional Requirement \texttt{FR-13}}
  \textit{Title}         & \textbf{Pure Iterative-Deepening A* Search} \\
  \textit{Description}   &
  Offer a function able to perform a IDA* Search that returns
  the list of all solutions found that way in the problem space. IDA*
  Search should be implemented using linear-memory search (\texttt{FR-03})
  and expanding the nodes in cost-heuristic search order.\\
  \textit{Priority}      & Medium \\
  \textit{Use-case(s)}   & \texttt{UC-01, UC-05} \\
\end{uc3m-table}


%%%%%%%%%%%%%%%%%%%%%%%%%%% MONADIC FRs %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{uc3m-table}{FR-14}{Functional Requirement \texttt{FR-14}}
  \textit{Title}         & \textbf{Search monad} \\
  \textit{Description}   &
  Design a monad that is able to collect run-time statistic in searches. The
  search monad should be able to keep these logs:
  \begin{enumerate}
  \item Number of expanded nodes.
  \item Number of enqueued nodes (if the search uses a data structure).
  \item Maximum length of the queue (if the search uses a data structure).
  \end{enumerate}\\
  \textit{Priority}      & Medium \\
  \textit{Use-case(s)}   & \texttt{UC-02} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-15}{Functional Requirement \texttt{FR-15}}
  \textit{Title}         & \textbf{Monadic general search method} \\
  \textit{Description}   &
  Following the general search algorithm mentioned in \cite{rusell-2003-aima},
  offer a function with similar capabilities, using a monadic functional style:
  using the search monad (\texttt{FR-14}) to collect run-time statistics of the
  search. This search should use a data structure (\texttt{FR-18}) to modify
  the behavior of the search.\\
  \textit{Priority}      & Low \\
  \textit{Use-case(s)}   & \texttt{UC-03} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-16}{Functional Requirement \texttt{FR-16}}
  \textit{Title}         & \textbf{Monadic linear-memory search method} \\
  \textit{Description}   &
  Offer a method that is able to perform a search while collecting run-time
  statistics and using linear memory to do so. This method has to be visible
  for the user to include in their own algorithms as well. \\
  \textit{Priority}      & Low \\
  \textit{Use-case(s)}   & \texttt{UC-03} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-17}{Functional Requirement \texttt{FR-17}}
  \textit{Title}         & \textbf{Monadic data structure interface} \\
  \textit{Description}   &
  Adapt the data structure interface defined for \texttt{FR-04} to handle
  monadic algorithms. That way, the user can also implement the search monad
  into their algorithms no matter if they use data structures.\\
  \textit{Priority}      & Low \\
  \textit{Use-case(s)}   & \texttt{UC-03} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-18}{Functional Requirement \texttt{FR-18}}
  \textit{Title}         & \textbf{Library of monadic data structures} \\
  \textit{Description}   &
  Adapt the data structures offered for pure algorithms (\texttt{FR-05}) to the
  search monad. \\
  \textit{Priority}      & Low \\
  \textit{Use-case(s)}   & \texttt{UC-03} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-19}{Functional Requirement \texttt{FR-19}}
  \textit{Title}         & \textbf{Monadic Breadth-First Search} \\
  \textit{Description}   &
  Offer a function able to perform a Breadth-First Search that returns the
  solution wrapped in the search monad with the statistics. Breadth-First Search
  should be implemented using general search (\texttt{FR-15}) and a First-In,
  First-Out queue (\texttt{FR-18}). \\
  \textit{Priority}      & Low \\
  \textit{Use-case(s)}   & \texttt{UC-02, UC-06} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-20}{Functional Requirement \texttt{FR-20}}
  \textit{Title}         & \textbf{Monadic Depth-First Search} \\
  \textit{Description}   &
  Offer a function able to perform a Depth-First Search that returns the
  solution wrapped in the search monad with the statistics. Depth-First Search
  should be implemented using linear-memory search (\texttt{FR-16}) or a
  Last-In, First-Out stack (\texttt{FR-18}).\\
  \textit{Priority}      & Low \\
  \textit{Use-case(s)}   & \texttt{UC-02, UC-06} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-21}{Functional Requirement \texttt{FR-21}}
  \textit{Title}         & \textbf{Monadic Iterative Depth-First Search} \\
  \textit{Description}   &
  Offer a function able to perform an Iterative Depth-First Search that returns
  the solution wrapped in the search monad with the statistics. Iterative
  Depth-First Search should be implemented using linear-memory search
  iteratively (\texttt{FR-16}) or a Last-In, First-Out depth-bounded stack
  (\texttt{FR-18}). \\ 
  \textit{Priority}      & Low \\
  \textit{Use-case(s)}   & \texttt{UC-02, UC-06} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-22}{Functional Requirement \texttt{FR-22}}
  \textit{Title}         & \textbf{Monadic Uniform-Cost Search} \\
  \textit{Description}   &
  Offer a function able to perform an Uniform-Cost Search that returns
  the solution wrapped in the search monad with the statistics. Uniform-Cost
  Search should be implemented using linear-memory search (\texttt{FR-16}).\\
  \textit{Priority}      & Low \\
  \textit{Use-case(s)}   & \texttt{UC-02, UC-06} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-23}{Functional Requirement \texttt{FR-23}}
  \textit{Title}         & \textbf{Monadic Greedy Search} \\
  \textit{Description}   &
  Offer a function able to perform a Greedy Search that returns solution
  wrapped in the search monad with the statistics. Greedy Search should be
  implemented using linear-memory search (\texttt{FR-16}) expanding the nodes
  with a minimal-heuristic order.\\ 
  \textit{Priority}      & Low \\
  \textit{Use-case(s)}   & \texttt{UC-02, UC-06} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-24}{Functional Requirement \texttt{FR-24}}
  \textit{Title}         & \textbf{Monadic A* Search} \\
  \textit{Description}   &
  Offer a function able to perform an A* Search that returns
  the solution wrapped in the search monad with the statistics. A*
  Search should be implemented using general search (\texttt{FR-15})
  using a priority queue to expand the nodes (\texttt{FR-18}). \\
  \textit{Priority}      & Low \\
  \textit{Use-case(s)}   & \texttt{UC-02, UC-06} \\
\end{uc3m-table}


\begin{uc3m-table}{FR-24}{Functional Requirement \texttt{FR-24}}
  \textit{Title}         & \textbf{Monadic Iterative-Deepening A* Search} \\
  \textit{Description}   &
  Offer a function able to perform a IDA* Search that returns
  the solution wrapped in the search monad with the statistics. IDA*
  Search should be implemented using linear-memory search (\texttt{FR-16})
  and expanding the nodes in cost-heuristic search order.\\
  \textit{Priority}      & Low \\
  \textit{Use-case(s)}   & \texttt{UC-02, UC-06} \\
\end{uc3m-table}


\newpage

\subsubsection{Non-Functional Requirements}

\begin{uc3m-table}{NFR-01}{Non-Functional Requirement \texttt{NFR-01}}
  \textit{Title}         & \textbf{Operating System} \\
  \textit{Description}   &
  The library can be used in any operating system that is able to run GHC and
  the Haskell platform, namely: Ubuntu, Arch Linux, FreeBSD, Gentoo Linux
  (x86-64 and x86), Fedora, Debian and NixOS.\\
  \textit{Priority}      & High \\
\end{uc3m-table}


\begin{uc3m-table}{NFR-02}{Non-Functional Requirement \texttt{NFR-02}}
  \textit{Title}         & \textbf{Haskell version} \\
  \textit{Description}   &
  The Haskell platform has to be installed in the system, which includes the
  GHC as well as other packaging, testing and documented tools needed for the
  system. The version included must be 8.0 or higher.\\
  \textit{Priority}      & High \\
\end{uc3m-table}


\begin{uc3m-table}{NFR-02}{Non-Functional Requirement \texttt{NFR-02}}
  \textit{Title}         & \textbf{Cabal version} \\
  \textit{Description}   &
  Cabal is a packaging tool, used for building and installing packages and
  dependencies in Haskell. The Cabal version has to be 1.24.0.0 or later.\\
  \textit{Priority}      & High \\
\end{uc3m-table}


\begin{uc3m-table}{NFR-03}{Non-Functional Requirement \texttt{NFR-03}}
  \textit{Title}         & \textbf{Dependencies} \\
  \textit{Description}   &
  All the dependencies needed for the library to properly work must be
  installed in the system. These dependencies are controlled by Cabal and
  require no further intervention by the user if Cabal is used for installing.
  The complete list of dependencies can be found in the package configuration
  file (\texttt{.cabal}).\\
  \textit{Priority}      & High \\
\end{uc3m-table}


\subsubsection{Traceability Matrix}

To better understand the relationship between use cases and requirements, a
traceability matrix is provided. In this matrix, we can see which requirements
are supposed to satisfy which use cases. Please notice that only functional
requirements are considered for the traceability matrix (since non-functional
requirements are stated as preconditions for the whole system to work at all).\\

\subsection{Implementation}

\newpage

%%% Local Variables:
%%% TeX-master: "tfg"
%%% End: