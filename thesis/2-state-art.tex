\section{State of the Art}

Before the main matter of the thesis, it is important to expose the current
state of the art, to check if the previous research done in the topics
related to this project. First, the section will sum up the current state of
the art in the algorithms that will be used by the thesis, as well as all
naming several libraries currently used for that purpose. Last, this section
will provide a basic state of the language to be used, Haskell; that will also
serve as a motivation for why to develop the project using this tool.\\

\subsection{Heuristic Search}

Heuristic Search is a problem solving method that belongs to Artificial
Intelligence \cite{rusell-2003-aima} used in robotics, pathfinding, computer
gaming among other fields. We can distinguish two types of heuristic search
algorithms: uninformed algorithms, which do not use a heuristic function and
perform a brute-force search; and informed algorithms, which use a heuristic
function to provide better performance than the aforementioned brute-force
algorithms.\\

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{img/empty-tree.png}
\caption{Example of a search tree}
\label{tree:empty}
\end{figure}

Although every algorithm included in this thesis can work with implicit graphs,
the best way to gain some intuition about them is to reflect their behavior on
a search tree, like the one in Figure \ref{tree:empty}. This tree presents a
root node (top of the image), from which is possible to see two different
oriented edges going out to two new nodes. This presents in a explicit way the
fact of being able to traverse the search space using operators given in a
problem space. The green nodes present final states. The objective of any
search algorithm then is to find a path from the root node (which is the
initial state defined in the problem space) to a final node, using different
constraints depending on the problem at hand: the shortest path, lowest cost
path, or just a solution that can be found in the shortest time possible. Using
this graphical representation, we can now go deep into explaining the current
state of the art of the algorithms that will be included in the framework.\\

\subsubsection{Uninformed Algorithms}

One of the basic brute-force algorithms is, undoubtedly, Breadth-First Search.
It was first introduced by Konrad Zuse in 1945, although published years later
\cite{zuse-1972-plankalkul}. This algorithm uses a queue (First In, First Out)
data structure to store the nodes expanded. The use of this queue to sort the
nodes to expand results in an exhaustive search per depth in the tree: first
the depth 0 nodes are expanded, the depth 1, the depth 2, etc, until the
solution is found or until the search space is completely exhausted. This
behavior can be appreciated in Figure \ref{tree:bfs}.\\

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{img/bfs.png}
\caption{Breadth-First Search execution on the tree}
\label{tree:bfs}
\end{figure}

In Figure \ref{tree:bfs} it is possible to see that the nodes are visited from
shallower to deeper levels, ensuring that the solution returned by this
algorithm is indeed the one with the shortest path from the initial state. The
algorithm is complete, that is, it will find a solution if it exists in the
search space, even if such space is infinite. The solution found will be the
nearest to the initial state, which is ensured to be the optimal if there no
variable costs. Its complexity is defined by $O(b^{d+1})$, where $b$ is the
branching factor of the problem and $d$ is the distance from the initial state
to the solution \cite{russel-2003-aima}.\\

\subsubsection{Informed Algorithms}

\subsubsection{Libraries}

Due to being more appropriate for the performance that is in general desired,
we can find that the most amount of work on Heuristic Search is done in
imperative, fast languages like C++ or Java.\\

In C++, we can find full search frameworks like \emph{HOG2} \cite{hog2},
\emph{Research code for heuristic search} \cite{cpp-search} or \emph{The
  Heuristic Search Research Framework} \cite{goldenberg-2017-framework}. All
these frameworks offer a full set of algorithms and procedures to override the
default implementations (such as cost, heuristic or expansion functions) in
order to adapt the library's behavior to the problem at hand. Also, these
frameworks offer visual representations options; a feature which is indeed the
main goal in the case of \emph{The Heuristic Search Research Framework}, that
offers a general visualization of algorithm behavior instead of domain specific
ones. On the other hand, in Java we can find similar projects like
\emph{Combinatorial Search for Java} \cite{cs4j} or \emph{AIMA}
\cite{java-aima}.\\

Trying to find similar projects in functional languages is more complicated
than that. However, one can find interesting projects like \emph{AIMA} written
in Common Lisp \cite{lisp-aima} or even a complete search framework written in
OCaml \cite{ocaml-search}. In Haskell, however, projects of this size are
nowhere to be found: All the algorithms are distributed in individual packages
with completely different implementations, as well as the data structures used
to perform the search.


\subsection{Haskell}

Haskell's first version was released in 1990 after the efforts of a committee
in FPCA '87 for creating an open standard for a ``non-strict, purely functional
language'' \cite{haskell-history}. Haskell's main features have remain patent
in the language, but constantly evolving: the language's main pillars are
\cite{haskell-98, haskell-2010}:

\begin{enumerate}
\item \textbf{Strong and statically typed}: the types are checked at compile
  time. That makes the run-time be sure that every function will get as
  parameter the expected object, making it more robust. However, no explicit
  type declaration is needed (although it is usually considered a good
  practice); types can be inferred most of the times by the compiler.
\item \textbf{Purely functional}: this type system is what allows Haskell to be
  purely functional. For Haskell, a string literal is of type \texttt{String},
  while an user's input on the prompt is a \texttt{IO String}. While at first
  shocking, this quality of Haskell maintains the referential transparency
  intact: the same function call with the same arguments is guaranteed to
  provide always the same output. All side effects are contained into monads
  (like the aforementioned \texttt{IO} monad) so they are contained and
  isolated.
\item \textbf{Lazy}: the fact that Haskell's evaluation is lazy (contrary to
  more common strict evaluation) means that a expression is only computed if
  its result is really necessary at a moment in time. This allows expressions
  to be defined in a much higher level: telling the computer what something is
  rather than how to compute it, and leaving the details of it to the compiler.
  Lazy evaluation provides for instance the use of infinite lists (since only
  the necessary part will be actually evaluated).
\item \textbf{Concurrent abstractions}: All the aforementioned characteristics
  also add up to the fact that the compiler is able to include concurrent
  optimizations into regular Haskell code thanks to its high-level definitions.
\end{enumerate}

Currently, the Glasgow Haskell Compiler (GHC) can be almost considered the
de-facto standard in Haskell compilers: widely spread and with an impressive
interface of pragmas to enable different optimizations by the compiler, it is
the compiler used for most projects because of the language extensions it
provides. Regarding packaging frameworks we can use Cabal, as a more
established option; or Stack, that wraps around Cabal configurations offering
more robust dependency installs and builds. Both frameworks offer several tools
for compilation, packaging, documentation, distribution, testing and profiling.
These tools will be explained in detail as they appear in the thesis.\\

Although not yet mainstream, Haskell is a language used in the industry that is
specially well-regarded in web backends: its concurrency is based in threads
that are so light that can be spawned in much larger densities than average
threads \cite{epstein-2011-cloud}. This fits specially well in a web server,
where every request can get one thread without compromising performance.
Haskell's type system also prevents different attacks (like SQL/XSS injection)
to be performed in these systems \cite{snoyman-2015-yesod}.

\newpage

%%% Local Variables:
%%% TeX-master: "tfg"
%%% End: